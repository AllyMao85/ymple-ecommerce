{
  "_args": [
    [
      {
        "raw": "flaverr@^1.0.0",
        "scope": null,
        "escapedName": "flaverr",
        "name": "flaverr",
        "rawSpec": "^1.0.0",
        "spec": ">=1.0.0 <2.0.0",
        "type": "range"
      },
      "/Users/fabienthetis/Documents/2017.10/Project_ymple/PRODUCT/ymple-commerce-1.0/node_modules/sails"
    ]
  ],
  "_from": "flaverr@>=1.0.0 <2.0.0",
  "_id": "flaverr@1.9.0",
  "_inCache": true,
  "_location": "/flaverr",
  "_nodeVersion": "8.1.2",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/flaverr-1.9.0.tgz_1512774440812_0.6034652329981327"
  },
  "_npmUser": {
    "name": "mikermcneil",
    "email": "npm@sailsjs.com"
  },
  "_npmVersion": "5.2.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "flaverr@^1.0.0",
    "scope": null,
    "escapedName": "flaverr",
    "name": "flaverr",
    "rawSpec": "^1.0.0",
    "spec": ">=1.0.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/machine",
    "/machine-as-action",
    "/machinepack-redis",
    "/parley",
    "/sails",
    "/sails-generate",
    "/whelk"
  ],
  "_resolved": "https://registry.npmjs.org/flaverr/-/flaverr-1.9.0.tgz",
  "_shasum": "205aeda8ea87c436d461cd7748b80ac7acf12bcf",
  "_shrinkwrap": null,
  "_spec": "flaverr@^1.0.0",
  "_where": "/Users/fabienthetis/Documents/2017.10/Project_ymple/PRODUCT/ymple-commerce-1.0/node_modules/sails",
  "author": {
    "name": "Mike McNeil"
  },
  "bugs": {
    "url": "https://github.com/mikermcneil/flaverr/issues"
  },
  "dependencies": {
    "@sailshq/lodash": "^3.10.2"
  },
  "description": "Flavor an Error instance with the specified error code string or dictionary of customizations.",
  "devDependencies": {
    "eslint": "4.11.0"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-PVkovjjvvgMMjsYYR1bSiSxRSt8K/Q6llEpBaaXKaKYbUv49r+W1gNvBlYmme01i71kixISibaBCP03T6OjJZQ==",
    "shasum": "205aeda8ea87c436d461cd7748b80ac7acf12bcf",
    "tarball": "https://registry.npmjs.org/flaverr/-/flaverr-1.9.0.tgz"
  },
  "gitHead": "ca69e6b5f2ec6a6f3eb478cc66dfe57cbb08c6f1",
  "homepage": "https://github.com/mikermcneil/flaverr#readme",
  "keywords": [
    "error",
    "error-handling",
    "stack-trace",
    "error-codes"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "mikermcneil",
      "email": "npm@sailsjs.com"
    }
  ],
  "name": "flaverr",
  "optionalDependencies": {},
  "readme": "# flaverr\n\nUtility library for JavaScript Errors, stack traces, and omens.\n\n> Take your JavaScript Errors to \"flavortown\".\n\n## Installation &nbsp; [![NPM version](https://badge.fury.io/js/flaverr.svg)](http://badge.fury.io/js/flaverr)\n\n```bash\n$ npm install flaverr\n```\n\n\n## Usage\n\nThe most basic usage of `flaverr` is just to call it as a function.\n\n#### Basics\n\nFlavor an Error instance with the specified error code string or dictionary of customizations:\n\n```js\nvar flaverr = require('flaverr');\n\nvar someError = new Error('Whoa whoa whoa!');\n//…\nsomeError = flaverr({\n  name: 'CompatibilityError',\n  code: 'E_WHOA_WHOA_WHOA'\n}, someError);\n```\n\n- If you provide a string as the first argument, that string will be set as the Error's `code`.\n- If you provide a dictionary as the first argument, that dictionary's keys will get folded into the Error as properties.\n\n\n#### Attach an error code\n\n```javascript\nvar err = new Error('Could not find user with the specified id.');\nerr = flaverr('E_NOT_FOUND', err);\n// => assert(err.code === 'E_NOT_FOUND' && err.message === 'Could not find user with the specified id.')\n// => assert(err.constructor.name === 'Error')\n```\n\n#### Attach arbitrary properties\n\n```javascript\nvar err = flaverr({\n  code: 'E_NOT_FOUND',\n  raw: { foo: 'bar' }\n}, new Error('Could not find user with the specified id.'));\n// => assert(err.code === 'E_NOT_FOUND' && err.message === 'Could not find user with the specified id.')\n// => assert(err.raw.foo === 'bar')\n// => assert(err.constructor.name === 'Error')\n```\n\n\n#### Improve the error message\n\n```javascript\nvar err = new Error('Could not find user with the specified id.');\nerr = flaverr({\n  name: 'ConsistencyViolation',\n  message: 'Logged-in user has gone missing!',\n  code: 'E_NOT_FOUND',\n  raw: { id: 123 }\n}, err);\n// => assert(err.code === 'E_NOT_FOUND' && err.message === 'Logged-in user has gone missing!')\n// => assert(err.raw.id === 123 && err.name === 'ConsistencyViolation')\n// => assert(err.constructor.name === 'Error')\n```\n\n#### Build a new Error\n\n```javascript\nvar err = flaverr({\n  name: 'ConsistencyViolation',\n  message: 'Logged-in user has gone missing!',\n  raw: { id: 123 }\n}, err);\n// => assert(err.code === 'notFound' && err.message === 'Logged-in user has gone missing!')\n// => assert(err.raw.id === 123 && err.name === 'ConsistencyViolation')\n// => assert(err.constructor.name === 'Error')\n```\n\n\n## A few examples of common use cases\n\n#### In .intercept()\n\n```javascript\nvar html = await sails.renderView('emails/email-verify-account', { token: '…' })\n.intercept('ENOENT', (err)=>flaverr({\n  code: 'E_MISSING_TEMPLATE_OR_LAYOUT',\n  message: 'Could not locate either template or layout file on disk.  '+err.message\n}));\n```\n\n\n#### In a `try` statement\n\n```javascript\ntry {\n  _.each(paths, function (thisPath) {\n    var isDirectory = fs.statFileSync(path.resolve(thisPath)).isDirectory();\n    if (!isDirectory) {\n      throw flaverr('notADirectory', new Error('One of the provided paths (`'+path.resolve(thisPath)+'`) points to something other than a directory.'));\n    }\n  });\n} catch (e) {\n  switch (e.code) {\n    case 'ENOENT': return exits.notFound();\n    case 'notADirectory': return exits.invalidPath(e);\n    default: return exits.error(e);\n  }\n}\n```\n\n\n#### Tagging an error with a code before sending it through an asynchronous callback\n\n```javascript\nif (err) { return done(err); }\nif (!user) {\n  return done(flaverr('notFound', new Error('Could not find a user with that id (`'+req.param('id')+'`).')));\n}\n```\n\n#### In a traditional asynchronous loop\n\n> This is less of a thing now that we have async/await!  But still leaving this example here for reference.\n\n```javascript\nasync.eachSeries(userRecords, function (user, next) {\n\n  if (user.pets.length === 0) {\n    return next(flaverr('noPets', new Error('User (`'+user.id+'`) has no pets yet!')));\n  }\n\n  if (!user.hobby) {\n    return next(flaverr('noHobby', new Error('Consistency violation: User (`'+user.id+'`) has no hobby!')));\n  }\n\n  async.each(user.pets, function (pet, next){\n    Pet.update().where({ id: pet.id })\n    .set({ likelyHobby: user.hobby })\n    .exec(next);\n  }, function (err){\n    if (err) { return next(err); }\n    if (err.code === 'E_UNIQUE') { return next(flaverr('nonUniquePetHobby', err)); }\n    return next();\n  });\n\n}, function afterwards(err) {\n  if (err) {\n    switch (err.code) {\n      case 'noPets': return res.send(409, err.message);\n      case 'noHobby': return res.serverError(err);\n      case 'nonUniquePetHobby': return res.send(409, 'A pet already exists with that hobby.');\n      default: return res.serverError(err);\n    }\n  }//--•\n\n  return res.ok();\n});\n```\n\n\n## Advanced\n\nSo, `flaverr()` can be used for more than just flavoring Error instances.\n\nSome of this stuff is pretty low-level, and intended to be used in building higher level libraries (not necessarily from app-level Node.js or browser JavaScript code).\n\nBut in the interest of completeness, here's what you can do:\n\n\n#### flaverr(…, …, caller)\n\nIf an optional third argument is passed in, it is understood as the caller-- i.e. the function where you called `flaverr()`.  If provided, this function will be used to improve the stack trace of the provided error.\n\n**This is particularly useful for customizing a stack trace; e.g. for building better omens.**  _By \"omen\", I mean an Error instance instantiated at an earlier time, so that when you use it at a later time, it has the right stack trace, and hasn't been \"cliffed out\" at an EventEmitter, setTimeout, setImmediate, etc._\n\n> Note: This is not a particularly speedy operation in JavaScript!  For most usages, it won't matter at all.  But for very hot code paths, or use cases that are highly sensitive to performance, you should consider avoiding this feature-- at least some of the time.\n>\n> For example, in parts of [Waterline ORM](http://waterlinejs.org) and the [machine runner](http://node-machine.org), this argument is omitted when running in a production environment:\n> ```js\n> var omen;\n> if (process.env.NODE_ENV!=='production' || process.env.DEBUG) {\n>   omen = flaverr({}, new Error('omen'), theCurrentFunction);\n> }\n>\n> //…\n> ```\n\nIn the example above, the stack trace of our omen will be snipped based on the instruction where this was invoked (i.e. whatever called \"theCurrentFunction\").\n\n\n\n#### flaverr.buildOmen()\n\nBuild an omen.\n\n> This is just a convenience method.\n\n\n```javascript\ndoSomethingThatRandomlyFailsSometimes();\n```\n\n```javascript\nfunction doSomethingThatRandomlyFailsSometimes() {\n  var omen;\n  if (process.env.NODE_ENV !== 'production' || process.env.DEBUG) {\n    omen = flaverr.buildOmen(doSomethingThatRandomlyFailsSometimes);\n  }\n\n  // …\n\n  if (Math.random() > 0.5) {\n    throw flaverr({\n      message: 'Wulp, it randomly failed.'\n    }, omen);\n  }\n\n}\n```\n\n\n#### flaverr.parseError()\n\nThere are certain Error-like values (e.g. from the bluebird library) that aren't quite ready to use as normal Errors, but can be easily parsed without being forced to construct a new Error instance or mutating anything.\n\nThis method provides a way to normalize errors like that.  If it determines that it cannot, then it just returns undefined.\n\n```js\n// …\nerr = flaverr.parseError(err) || err;\n\nif (_.isError(err)) {\n  throw flaverr({\n    message: 'Something went wrong in aisle 6: '+err.message\n  }, omen);\n}\nelse {\n  throw flaverr({\n    message: 'Something went wrong in aisle 6: '+util.inspect(err, {depth:5})\n  }, omen);\n}\n```\n\n\n#### flaverr.parseOrBuildError()\n\nSometimes, you really want to make sure you have an Error instance, no matter what-- even if you have to construct one!\n\nThis method does just that.\n\n```javascript\n// …\n\nerr = flaverr.parseOrBuildError(err, omen);\nthrow flaverr({\n  message: 'Something went wrong in aisle 6: '+err.message\n}, err);\n```\n\n\n#### flaverr.getBareTrace()\n\nReturn the bare stack trace of an Error, with the identifying preamble (`.name` + colon + space + `.message`) trimmed off, leaving only the info about stack frames.\n\nThis is **particularly useful for including proper context within warning messages**.  (More rarely, it's useful for situations where you want an error to contain more than one trace-- although in that case, it's usually best to store the nested error as a separate property, such as `.raw`.  See `.wrap()` for ideas.)\n\n\nIf you pass in an error, its stack trace will be harvested:\n\n```js\nvar err = new Error('Some error');\n\nflaverr.getBareTrace(err);\n//=>\n//'    at repl:1:28\\n    at ContextifyScript.Script.runInThisContext (vm.js:44:33)\\n    at REPLServer.defaultEval (repl.js:239:29)\\n    at bound (domain.js:301:14)\\n    at REPLServer.runBound [as eval] (domain.js:314:12)\\n    at REPLServer.onLine (repl.js:433:10)\\n    at emitOne (events.js:120:20)\\n    at REPLServer.emit (events.js:210:7)\\n    at REPLServer.Interface._onLine (readline.js:278:10)\\n    at REPLServer.Interface._line (readline.js:625:8)'\n// ^^^ this is a string\n```\n\n\nIf nothing is passed in, a new Error will be instantiated on the fly and its stack will be used:\n\n```js\nflaverr.getBareTrace();\n//=>\n//'    at repl:1:28\\n    at ContextifyScript.Script.runInThisContext (vm.js:44:33)\\n    at REPLServer.defaultEval (repl.js:239:29)\\n    at bound (domain.js:301:14)\\n    at REPLServer.runBound [as eval] (domain.js:314:12)\\n    at REPLServer.onLine (repl.js:433:10)\\n    at emitOne (events.js:120:20)\\n    at REPLServer.emit (events.js:210:7)\\n    at REPLServer.Interface._onLine (readline.js:278:10)\\n    at REPLServer.Interface._line (readline.js:625:8)'\n```\n\nIf a function is passed in instead of an Error, it is understood to be a \"caller\" from somewhere on the current call stack.  A new Error will be instantiated instead, and the provided function will be used to align the stack trace of that new Error so that it begins at the point the provided function was called:\n\n```js\nfunction foo() {\n  console.log(flaverr.getBareTrace(foo));\n}\n\nfoo();\n//=>\n//'    at repl:1:28\\n    at ContextifyScript.Script.runInThisContext (vm.js:44:33)\\n    at REPLServer.defaultEval (repl.js:239:29)\\n    at bound (domain.js:301:14)\\n    at REPLServer.runBound [as eval] (domain.js:314:12)\\n    at REPLServer.onLine (repl.js:433:10)\\n    at emitOne (events.js:120:20)\\n    at REPLServer.emit (events.js:210:7)\\n    at REPLServer.Interface._onLine (readline.js:278:10)\\n    at REPLServer.Interface._line (readline.js:625:8)'\n// ^^Note that `foo()` does not appear in the stack trace like it normally would.\n```\n\n\nFinally, to tie that all together, here is a more real-world example lifted straight out of [parley](https://npmjs.com/package/parley):\n\n```javascript\n// Implementorland spinlock\nif (self._hasFinishedExecuting) {\n  console.warn(\n    '- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\\n'+\n    'WARNING: Something seems to be wrong with this function.\\n'+\n    'It is trying to signal that it has finished AGAIN, after\\n'+\n    'already resolving/rejecting once.\\n'+\n    '(silently ignoring this...)\\n'+\n    '\\n'+\n    'To assist you in hunting this down, here is a stack trace:\\n'+\n    '```\\n'+\n    flaverr.getBareTrace(self._omen)+'\\n'+\n    '```\\n'+\n    '\\n'+\n    ' [?] For more help, visit https://sailsjs.com/support\\n'+\n    '- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'\n  );\n  return;\n}\n```\n\n> ##### The second argument to .getBareTrace()\n>\n> .getBareTrace() also accepts a second argument, `framesToKeep`: the number of frames from the top of the call stack to retain in the output trace.  (i.e. all other stack frames will be trimmed off)\n>\n> ```js\n> //\n> var top3StackFrames = flaverr.getBareTrace(self._omen, 3);\n> ```\n>\n> In the general case, without this argument, all frames will be included- up to the JavaScript engine's configured stack trace depth.  **This default behavior is good, and is how you should leave things in the vast majority of cases.**\n> Especially never use the second argument unless your code is aware of the source of the error being trimmed, and you're sure that all relevant context will exist in the top _n_ stack frames.\n> Proceed at your own risk.  You have been warned!\n\n\n## Help\n\nIf you have a question, need commercial support from the engineers who build Sails, or you just want to talk Sails/Node.js with other folks in the community, click [here](https://sailsjs.com/support).\n\n\n## Bugs &nbsp; [![NPM version](https://badge.fury.io/js/flaverr.svg)](http://npmjs.com/package/flaverr)\n\nTo report a bug, [click here](https://sailsjs.com/bugs).\n\n\n## Contributing\n\nPlease observe the guidelines and conventions laid out in the [Sails project contribution guide](https://sailsjs.com/documentation/contributing) when opening issues or submitting pull requests.\n\n[![NPM](https://nodei.co/npm/flaverr.png?downloads=true)](http://npmjs.com/package/flaverr)\n\n## License\n\nMIT &copy; 2016, 2017 [Mike McNeil](https://twitter.com/mikermcneil)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/mikermcneil/flaverr.git"
  },
  "scripts": {
    "custom-tests": "echo \"(No other custom tests yet.)\" && echo # node ./node_modules/mocha/bin/mocha test --recursive && echo \"Custom tests all passed.\" && echo",
    "lint": "node ./node_modules/eslint/bin/eslint . --max-warnings=0 && echo '✔  Your code looks good.'",
    "sandbox": "node -i -e '_ = require(\"@sailshq/lodash\"); global[require(\"./package.json\").name] = require(\"./\"); console.log(\"\\n\\n\\n\\n--\");'",
    "test": "npm run lint && npm run custom-tests && echo 'Done.'"
  },
  "version": "1.9.0"
}
