{
  "_args": [
    [
      {
        "raw": "parley@^3.3.1",
        "scope": null,
        "escapedName": "parley",
        "name": "parley",
        "rawSpec": "^3.3.1",
        "spec": ">=3.3.1 <4.0.0",
        "type": "range"
      },
      "/Users/fabienthetis/Documents/2017.10/Project_ymple/PRODUCT/ymple-commerce-1.0/node_modules/sails"
    ]
  ],
  "_from": "parley@>=3.3.1 <4.0.0",
  "_id": "parley@3.3.4",
  "_inCache": true,
  "_location": "/parley",
  "_nodeVersion": "8.1.2",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/parley-3.3.4.tgz_1512791508018_0.9441450217273086"
  },
  "_npmUser": {
    "name": "mikermcneil",
    "email": "npm@sailsjs.com"
  },
  "_npmVersion": "5.2.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "parley@^3.3.1",
    "scope": null,
    "escapedName": "parley",
    "name": "parley",
    "rawSpec": "^3.3.1",
    "spec": ">=3.3.1 <4.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/machine",
    "/sails"
  ],
  "_resolved": "https://registry.npmjs.org/parley/-/parley-3.3.4.tgz",
  "_shasum": "1769bbdaa79f2b2cc659b3f8810f0b24ba48591b",
  "_shrinkwrap": null,
  "_spec": "parley@^3.3.1",
  "_where": "/Users/fabienthetis/Documents/2017.10/Project_ymple/PRODUCT/ymple-commerce-1.0/node_modules/sails",
  "author": {
    "name": "Mike McNeil"
  },
  "bugs": {
    "url": "https://github.com/mikermcneil/parley/issues"
  },
  "dependencies": {
    "@sailshq/lodash": "^3.10.2",
    "bluebird": "3.2.1",
    "flaverr": "^1.5.1"
  },
  "description": "Practical, lightweight flow control for Node.js.  Supports `await`, callbacks and promises.",
  "devDependencies": {
    "benchmark": "2.1.2",
    "eslint": "4.11.0",
    "mocha": "3.0.2"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-mx0cU+MIOqKaZRcYqBtoxHoW3UvtTGSwYYA3OZ4EI9V/NySyLpLja0OoqlA4SsNraRWNivyW08vp7Me3EYHHKw==",
    "shasum": "1769bbdaa79f2b2cc659b3f8810f0b24ba48591b",
    "tarball": "https://registry.npmjs.org/parley/-/parley-3.3.4.tgz"
  },
  "gitHead": "05ff7d4ea6ed6d81299229a9ec76d634aac94a50",
  "homepage": "https://github.com/mikermcneil/parley#readme",
  "keywords": [
    "flowcontrol",
    "await",
    "async/await",
    "async",
    "promise",
    "callback",
    "deferred"
  ],
  "license": "MIT",
  "main": "lib/parley.js",
  "maintainers": [
    {
      "name": "mikermcneil",
      "email": "npm@sailsjs.com"
    },
    {
      "name": "balderdashy",
      "email": "mike@balderdash.co"
    }
  ],
  "name": "parley",
  "optionalDependencies": {},
  "readme": "parley\n=========\n\nPractical, lightweight flow control for Node.js, with support for `await`, deferred execution, traditional Node callbacks, and promise chaining.\n\n> Powered by [bluebird](http://bluebirdjs.com/)\n\n\n## Usage\n\nThese days, there are several different common ways that developers call functions in Node.js and JavaScript.  Parley helps _your code_ support all three of the mainstream flow control paradigms.\n\nParley helps you write functions that can be called like this:\n\n```javascript\nvar result = await doStuff({ foo: 123 }).foo({ bar: 456 });\n```\n\nOr like this:\n\n```javascript\ndoStuff({ foo: 123 })\n.foo({ bar: 456 })\n.exec(function (err, result){\n\n});\n```\n\nOr even like this:\n\n```javascript\ndoStuff({ foo: 123 })\n.baz({ bar: 456 })\n.then(function (result){\n\n})\n.catch(function(err) {\n\n});\n```\n\n> parley functions return a Deferred.  You can also obtain a promise simply by calling [`.toPromise()`](#toPromise).\n\n\n## About\n\nParley is brought to you by [the team behind Sails.js](https://sailsjs.com/about), and used internally by the [Sails framework](https://sailsjs.com), [Waterline ORM](http://waterlinejs.org), the [node-machine project](http://node-machine.org), and more.  \n\n\n## Compatibility\n\nCompatible with Node 8, Node 6, Node 4, Node 0.12, and Node 0.10.  (But note that `await` is not supported by Node versions < 7.9.)\n\n\n## Benchmarks\n\nAs of July 3, 2017:\n\n```\n  baseline.benchmark.js\n  •  •      •       •      •    •    \n           •      •              o  \n  •    b e n c h m a r k s      •    \n   •    (instantiation)       °     \n------------------------------------\n    parley(handler)\n • just_build#0 x 28,097,782 ops/sec ±1.42% (90 runs sampled)\n      ✓ should be performant enough (using benchSync())\n    parley(handler).exec(cb)\n • build_AND_exec#0 x 3,185,038 ops/sec ±1.53% (93 runs sampled)\n      ✓ should be performant enough (using benchSync())\n    parley(handler, undefined, {...})  (w/ 9 custom methods)\n • just_build_with_9_custom_methods#0 x 4,274,101 ops/sec ±1.38% (89 runs sampled)\n      ✓ should be performant enough (using benchSync())\n    parley(handler, undefined, {...}).exec(cb)   (w/ 9 custom methods)\n • build_AND_exec_with_9_custom_methods#0 x 1,822,064 ops/sec ±1.24% (88 runs sampled)\n      ✓ should be performant enough (using benchSync())\n    practical benchmark\n • mock \"find().exec()\"#0 x 34.61 ops/sec ±0.99% (78 runs sampled)\n      ✓ should be performant enough when calling fake \"find\" w/ .exec() (using bench())\n • mock \"find(..., explicitCb)\"#0 x 35.04 ops/sec ±1.11% (79 runs sampled)\n      ✓ should be performant enough when calling NAKED fake \"find\" (using bench())\n • mock \"validate().exec()\"#0 x 1,463,995 ops/sec ±1.03% (89 runs sampled)\n      ✓ should be performant enough when calling fake \"validate\" w/ .exec() (using benchSync())\n • mock \"validate().exec()\"#0 x 1,240,289 ops/sec ±2.69% (94 runs sampled)\n      ✓ should be performant enough when calling fake \"validate\" w/ .exec() + uncaught exception handler (using benchSync())\n • mock \"validateButWith9CustomMethods().exec()\"#0 x 1,030,355 ops/sec ±2.26% (96 runs sampled)\n      ✓ should be performant enough calling fake \"validateButWith9CustomMethods\" w/ .exec() (using benchSync())\n • mock \"validate(..., explicitCb)\"#0 x 9,696,815 ops/sec ±2.76% (88 runs sampled)\n      ✓ should be performant enough when calling NAKED \"validate\" (using benchSync())\n------------------------------------\n  •  •      •       •      •    •    \n           •      •              o  \n  • < / b e n c h m a r k s >    •    \n   •                           °     \n                      o°            \n```\n\n\n_Originally, back in January 15, 2017:_\n\n```\n    parley(handler)\n • just_build#0 x 18,162,364 ops/sec ±0.98% (90 runs sampled)\n      ✓ should be performant enough (using benchSync())\n    parley(handler).exec(cb)\n • build_AND_exec#0 x 1,804,891 ops/sec ±1.77% (84 runs sampled)\n      ✓ should be performant enough (using benchSync())\n    parley(handler, undefined, {...})  (w/ 9 custom methods)\n • just_build_with_9_custom_methods#0 x 3,947,502 ops/sec ±1.62% (90 runs sampled)\n      ✓ should be performant enough (using benchSync())\n    parley(handler, undefined, {...}).exec(cb)   (w/ 9 custom methods)\n • build_AND_exec_with_9_custom_methods#0 x 1,259,925 ops/sec ±2.08% (76 runs sampled)\n      ✓ should be performant enough (using benchSync())\n    practical benchmark\n • mock \"find().exec()\"#0 x 33.69 ops/sec ±0.98% (73 runs sampled)\n      ✓ should be performant enough when calling fake \"find\" w/ .exec() (using bench())\n • mock \"find(..., explicitCb)\"#0 x 33.93 ops/sec ±0.90% (73 runs sampled)\n      ✓ should be performant enough when calling NAKED fake \"find\" (using bench())\n • mock \"validate().exec()\"#0 x 789,446 ops/sec ±1.85% (92 runs sampled)\n      ✓ should be performant enough when calling fake \"validate\" w/ .exec() (using benchSync())\n • mock \"validateButWith9CustomMethods().exec()\"#0 x 686,544 ops/sec ±1.21% (90 runs sampled)\n      ✓ should be performant enough calling fake \"validateButWith9CustomMethods\" w/ .exec() (using benchSync())\n • mock \"validate(..., explicitCb)\"#0 x 10,157,027 ops/sec ±1.77% (87 runs sampled)\n      ✓ should be performant enough when calling NAKED \"validate\" (using benchSync())\n```\n\n\n## Help\n\nIf you have questions or are having trouble, click [here](http://sailsjs.com/support).\n\nIf you're in a hurry to use a _parley-enabled API in practice_, it might help to check out a couple of real-world examples:\n• [.find()](https://github.com/balderdashy/sails-docs/blob/f4858b0d3c6bb80bc130060ecdd428e735ec111e/reference/waterline/models/find.md)  _(in Sails.js / Waterline ORM)_\n• [`.build()`](https://github.com/node-machine/machine/tree/c65d6430d72fa93c794f0f80344665028b94cb0c#callables)  _(in `machine`)_\n\nIf you're interested in learning more about this approach to async flow control in general, or considering using parley to support `await`, promises, and traditional Node callbacks _for your own functions_, then keep reading-- there's a whole lot more for you below.\n\n## Bugs &nbsp; [![NPM version](https://badge.fury.io/js/parley.svg)](http://npmjs.com/package/parley)\n\nTo report a bug, [click here](http://sailsjs.com/bugs).\n\n\n\n## Overview\n\nThis section offers a high-level look at how to use parley from both a userland and implementor perspective.  You can also skip ahead to the [API reference below](#api-reference).\n\n\n### Building a deferred object\n\nUse parley to build a **deferred object**.  This provides access to `.exec()`, `.then()`, `.catch()`, and `.toPromise()`, but you can also attach any extra methods you'd like to add.  (There are also a few extra methods like `.log()` provided automatically as syntactic sugar-- more on that below.)\n\n```javascript\nvar parley = require('parley');\n\nvar deferred = parley(function (done){\n  setTimeout(function (){\n    if (Math.random() > 0.5) {\n      return done(new Error('whoops, unlucky I guess'));\n    }\n    if (Math.random() > 0.2) {\n      return done(undefined, Math.floor(5*Math.random()));\n    }\n    return done();\n  }, 50);\n});\n```\n\n> For a more complete version of the above example, [click here](https://gist.github.com/mikermcneil/621b55cfc54f133a1db30d7238ca52b1).\n\n\n### Results\n\nTo send back a result value from your handler, specify it as the second argument when invoking `done`.\n\n```javascript\nreturn done(undefined, 'hello world');\n```\n\nDepending on how userland code chooses to work with the deferred object, your result will be passed back to userland as either the return value, the second argument to the `.exec()` callback, or as the value resolved from the promise.\n\n```javascript\n// Recommended approach   (available in Node.js >= v7.9)\nvar result = await yourFn();\n```\n\n```javascript\n// traditional Node-style callback\n.exec(function(err, result) {\n  // => undefined, 'hello world'\n});\n\n// or legacy promise chaining\n.then(function(result) {\n  // => 'hello world'\n});\n```\n\n\n### Errors\n\nTo send back an error from your handler, handle it in the conventional Node.js way.\n\n```javascript\nreturn done(new Error('Oops'));\n```\n\nDepending on how userland code chooses to work with the deferred object, your error will be passed back to userland as either the first argument to the `.exec()` callback, or as the promise's rejection \"reason\".\n\n```javascript\n// Recommended approach   (available in Node.js >= v7.9)\nvar result;\ntry {\n  result = await yourFn();\n} catch (err) {\n  // => [Error: oops]\n}\n```\n\n```javascript\n// traditional Node-style callback\n.exec(function(err, result) {\n  // => [Error: oops], undefined\n});\n\n// or legacy promise-chaining\n.catch(function(err) {\n  // => [Error: oops]\n});\n```\n\n#### Custom exceptions\n\nSometimes, there is one or more \"exceptional\" exit a function might take, which are fundamentally different than other generic errors that might occur-- for example, consider the difference between a \"someone with that username already exists\" exception and a bug resulting from a typo, missing dependency, etc.\n\nTo make it possible for userland code to negotiate different exits from your function, give your error a `code` property.\n\n```javascript\nvar x = Math.random();\n\n// Miscellaneous error (no code)\nif (x > 1) {\n  return done(new Error('Consistency violation: This should never happen.'));\n}\n\nvar flaverr = require('flaverr');\n// Other recognized exceptions\nif (x > 0.6) {\n  return done(flaverr('E_TOO_BIG', new Error('Oops: too big')));\n}\nif (x < 0.4) {\n  return done(flaverr('E_TOO_SMALL', new Error('Too small -- probably already in use!')))\n}\n```\n\n#### Negotiating errors\n\nThe aforementioned approach makes it easy to negotiate errors in userland.  Whether the userland code is using `await`, a Node-style callback, or promise-chaining, the underlying approach is conceptually the same regardless.\n\n```javascript\n// Recommended approach   (available in Node.js >= v7.9)\nvar result;\ntry {\n  result = await yourFn();\n} catch (err) {\n  switch(err.code) {\n    case 'E_TOO_BIG': return res.status(400).json({ reason: 'Ooh, too bad!  '+err.message });\n    case 'E_TOO_SMALL': return res.status(401).json({ reason: 'Please try again later.  '+err.message });\n    default:\n      console.error('Unexpected error:',err.stack);\n      return res.sendStatus(500);\n  }\n}\n\n// …\n```\n\n\n```javascript\n// traditional Node-style callback\n.exec(function(err, result) {\n  if (err) {\n    switch(err.code) {\n      case 'E_TOO_BIG': return res.status(400).json({ reason: 'Ooh, too bad!  '+err.message });\n      case 'E_TOO_SMALL': return res.status(401).json({ reason: 'Please try again later.  '+err.message });\n      default:\n        console.error('Unexpected error:',err.stack);\n        return res.sendStatus(500);\n    }\n  }//-•\n\n  // ...\n});\n```\n\n```Javascript\n// or legacy promise-chaining\n.then(function (result) {\n  // ...\n})\n.catch({ code: 'E_TOO_BIG' }, function(err) {\n  return res.status(400).json({ reason: 'Ooh, too bad!  '+err.message });\n})\n.catch({ code: 'E_TOO_SMALL' }, function(err) {\n  return res.status(401).json({ reason: 'Please try again later.  '+err.message });\n})\n.catch(function(err) {\n  console.error('Unexpected error:',err.stack);\n  return res.sendStatus(500);\n});\n```\n\n\n#### Handling uncaught exceptions\n\nFor a long time, uncaught exceptions were the skeletons in JavaScript's closet.  That's because, out of the box, when using asynchronous callbacks in Node.js, _if the code in your callback throws an uncaught error, the process **will crash!**_\n\nFor example, the following code would crash the process:\n\n```javascript\nsetTimeout(function (){\n\n  // Since this string can't be parsed as JSON, this will throw an error.\n  // And since we aren't using try...catch, it will crash the process.\n  JSON.parse('who0ps\"thisis totally not valid js{}n');\n\n  return res.ok();\n\n}, 50);\n```\n\nThis behavior leads to stability issues, wasted dev hours, security vulnerabilities, extreme susceptibility to denial-of-service attacks, weeping, crying, moaning, therapist appointments and much wailing and gnashing of teeth.\n\n**But if you're using Node >= v7.9, you're in luck.  [`await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await) solves _all_ of these problems.**\n\n> If you're new to Node, congratulations!  You're getting started at _the best possible time_.  It's never been faster, easier, and more secure to build apps with JavaScript.\n>\n> And for those of us that have been using Node.js for years, these are incredibly exciting times to be a Node.js developer.  As a community, we've finally conquered one of Node's biggest challenges and it's often-quoted only remaining hurdle to adoption: \"callback hell\".   The callbacks are dead.  Long live `await`!\n\n#### What if I'm stuck with an old version of Node.js?\n\nWell, then buckle up.  \n\nTo protect against the problems mentioned above, you'll need to always be sure to use try...catch blocks around any logic\nthat might throw in an asynchronous, Node-style callback.\n\nFor example:\n\n```javascript\nsetTimeout(function (){\n\n  try {\n    JSON.parse('who0ps\"thisis totally not valid js{}n');\n  } catch (e) { return res.serverError(e); }\n\n  return res.ok();\n\n}, 50);\n```\n\nHere are a few common use cases to watch out for:\n+ basic JavaScript errors; e.g. syntax issues, or trying to use the dot (.) operator on `null`.\n+ trying to JSON.parse() some data that is not a valid, parseable JSON string\n+ trying to JSON.stringify() a circular object\n+ RPS methods in Sails.js; e.g. `.publish()`, `.subscribe()`, `.unsubscribe()`\n+ Waterline's `.validate()` model method\n+ Node core's `assert()`\n+ most synchronous methods from Node core (e.g. `fs.readFileSync()`)\n+ any synchronous machine called with `.execSync()`\n+ other synchronous functions from 3rd party libraries\n\n\n_Note that this is not an issue when using promises, since `.then()` automatically catches uncaught errors\n(although there are other considerations when using promises-- for instance, forgetting to use .catch()\neach time .then() is used is a common source of hard-to-debug issues, technical debt, and memory leaks.)_\n\n\n> **EXPERIMENTAL:** As of parley 2.3.x, there is a new, experimental feature that allows you to\n> easily provide an extra layer of protection: an optional 2nd argument to `.exec()`.  If specified,\n> this function will be used as an uncaught exception handler-- a simple fallback just in case something\n> happens to go wrong in your callback function.\n>\n> This allows you to safely write code like the following without crashing the server:\n>\n> ```javascript\n> User.create({ username: 'foo' }).exec(function (err, result) {\n>   if (err) {\n>     if (err.code === 'E_UNIQUE') { return res.badRequest('Username already in use.'); }\n>     else { return res.serverError(err); }\n>   }\n>\n>   var thisWillNeverWork = JSON.parse('who0ps\"thisis totally not valid js{}n');\n>\n>   return res.json(result);\n>\n> }, res.serverError);\n> ```\n>\n> Of course, it's still best to be explicit about error handling whenever possible.\n> The extra layer of protection is just that-- it's here to help prevent issues\n> stemming from the myriad runtime edge cases it's almost impossible to anticipate\n> when building a production-ready web application.\n\n\n#### Tolerating errors\n\nSometimes, you just don't care.\n\n```javascript\nvar result = await sails.stdlib('fs').readJson({ source: './package.json' })\n.tolerate('notFound', ()=>{\n  return {\n    name: 'not-a-real-package',\n    description: 'This is not a real package, and I don\\'t care.'\n  };\n});\n\n// Now `result` is either the contents of the real package.json file... or our fake stuff.\n```\n\n\n#### Catching and rethrowing errors\n\nBut sometimes, you care a little _too_ much.\n\n```javascript\nvar result = await sails.stdlib('fs').readJson({ source: './package.json' })\n.intercept('notFound', (err)=>{\n  return flaverr({\n    message: 'No package.json file could be found in the current working directory.  And I care _very_ much.',\n    code: 'E_WHERE_IS_MY_PACKAGE_JSON'\n  }, err);\n});\n\n// If the package.json file doesn't exist, we will have now thrown a much more useful error.\n```\n\n\n\n### Flow control\n\nIf you're using Node >= v7.9, you're in luck.  With `await`, flow control works just like it does in any other language (with one exception: parallel processing/races.  More on that below.)\n\n\n##### What if I'm stuck with an old version of Node.js?\n\nSorry to hear that...  Once again, `await` solves all of these problems too.  It's the biggest boon to JavaScript development since Node.js was released.\n\nBut don't worry- this section's for you.  Since Node.js is asynchronous, when using Node < v7.9, seemingly-tricky flow control problems often arise in practical, userland code.  Fortunately, they're easy to solve when equipped with the proper tools and strategies.\n\n> Most of the examples below use simple Node callbacks, but note that many similar affordances are available for promise-chaining -- for example, check out `.toPromise()` ([below](#toPromise)) and `Promise.all()` (in bluebird, or native in ES6, etc.).  The concepts are more or less the same regardless.\n>\n> _Unless you and the rest of your team are experts with legacy promise-chaining and already have tight, consistently-applied and agreed-upon conventions for how to implement the use cases below, you're probably best off using Node callbacks._\n\n#### Async loops\n\nUsing Node >= v7.9?  You can just do a `for` loop.\n\n```javascript\nvar results = [];\nfor (let letter of ['a','b','c','d','e','f','g','h','i','j','k','l']) {\n  results.push(await doStuff(letter));\n}\nreturn res.json(results);\n```\n\nBut otherwise...\n\n\n##### What if I'm stuck with an old version of Node.js?\n\nLoop over many asynchronous things, one at a time, using `async.eachSeries()`.\n\n> For this example, make sure you have access to the [`async` library](http://npmjs.com/package/async):\n>\n>```javascript\n>var async = require('async');\n>```\n\n```javascript\nvar results = [];\nasync.eachSeries(['a','b','c','d','e','f','g','h','i','j','k','l'], function (letter, next) {\n  doStuff(letter).exec(function (err, resultForThisLetter){\n    if (err) { return next(err); }\n    results.push(resultForThisLetter)\n    return next();\n  });\n},\n// ~∞%°\nfunction afterwards(err) {\n  if (err) {\n    console.error(err);\n    return res.sendStatus(500);\n  }\n  return res.json(results);\n});\n```\n\n#### Async \"if\"\n\nUsing Node >= v7.9?  You can just do an `if` statement.\n\n```javascript\nvar profileUser = await User.findOne({ id: req.param('id') });\nif (!profileUser) { return res.notFound(); }\n\nvar loggedInUser;\nif (req.session.userId) {\n  loggedInUser = await User.findOne({ id: req.session.userId });\n}\n\nreturn res.view('profile', {\n  profile: _.omit(profileUser, ['password', 'email']),\n  me: loggedInUser ? _.omit(loggedInUser, 'password') : {}\n});\n```\n\nBut otherwise...\n\n##### What if I'm stuck with an old version of Node.js?\n\nEven simple detours and conditionals can sometimes be tricky when things get asynchronous.\n\nFortunately, relatively concise and robust branching logic can be easily implemented using out-of-the-box JavaScript using this weird trick™.\n\n```javascript\nUser.findOne({ id: req.param('id') })\n.exec(function(err, profileUser) {\n  if (err) { return res.serverError(err); }\n  if (!profileUser) { return res.notFound(); }\n\n  // If the request came from a logged in user,\n  // then fetch that user's record from the database.\n  (function(proceed) {\n    if (!req.session.userId) {\n      return proceed();\n    }\n    User.findOne({ id: req.session.userId })\n    .exec(function (err, loggedInUser) {\n      if (err) { return proceed(err); }\n      if (!loggedInUser) { return proceed(new Error('Logged-in user ('+req.session.userId+') is missing from the db!')); }\n      return proceed(undefined, loggedInUser);\n    });\n\n  // ~∞%°\n  })(function afterwards(err, loggedInUser){\n    if (err) { return res.serverError(err); }\n\n    return res.view('profile', {\n      profile: _.omit(profileUser, ['password', 'email']),\n      me: loggedInUser ? _.omit(loggedInUser, 'password') : {}\n    });\n\n  });\n});\n```\n\n> [More background on using the if/then/finally pattern for asynchronous flow control](https://gist.github.com/mikermcneil/32391da94cbf212611933fabe88486e3)\n\n\n#### Async recursion\n\nUsing Node >= v7.9?  Recursion is never exactly \"fun and easy\" (IMO) but with `await`, you can do recursion just like you would with normal, synchronous code (like any other programming language):\n\n```javascript\n#!/usr/bin/env node\n\nvar path = require('path');\nvar stdlib = require('sails-stdlib'); \n\n// Starting from the current working directory, ascend upwards\n// looking for a package.json file.  (Keep looking until we hit an error.)\nvar nearestPJ = await (async function _recursively(thisDir){\n  var pathToCheck = path.resolve(thisDir, './package.json');\n  try {\n    await stdlib('fs').exists({path: pathToCheck});\n  } catch (err) {\n    if (err.code === 'doesNotExist') {\n      return _recursively(path.dirname(thisDir));\n    }\n    else {\n      throw err;\n    }\n  }\n  \n  // Otherwise, if there was no error, we found it!\n  return pathToCheck;\n})(process.cwd());\n\nconsole.log('Found nearest package.json file at:',nearestPJ);\n```\n\n\n\nBut otherwise...\n\n##### What if I'm stuck with an old version of Node.js?\n\nMuch like \"if/then/finally\" above, the secret to tidy asynchronous recursion is the (notorious) self-calling function.\n\n```javascript\n#!/usr/bin/env node\n\nvar path = require('path');\nvar fs = require('fs');\n\n// Starting from the current working directory, ascend upwards\n// looking for a package.json file.  (Keep looking until we hit an error.)\n(function _recursively(thisDir, done){\n\n  var pathToCheck = path.resolve(thisDir, './package.json');\n  fs.stat(pathToCheck, function(err) {\n    if (err) {\n      switch (err.code) {\n\n        // Not found -- so keep going.\n        case 'ENOENT':\n          var oneLvlUp = path.dirname(thisDir);\n          _recursively(oneLvlUp, function(err, nearestPJ) {\n            if (err) { return done(err); }\n            return done(undefined, nearestPJ);\n          });\n          return;\n\n        // Misc. error\n        default: return done(err);\n      }\n    }//-•\n\n    // Otherwise, found it!\n    return done(undefined, pathToCheck);\n\n  });//</ fs.exists >\n\n// ~∞%°\n})(process.cwd(), function afterwards(err, nearestPJ) {\n  if (err) {\n    console.error(err);\n    return process.exit(1);\n  }\n\n  console.log('Found nearest package.json file at:',nearestPJ);\n\n});\n```\n\n> [More examples and thoughts on asynchronous recursion](https://gist.github.com/mikermcneil/225198a46317050af1f772296f67e6ce)\n\n\n\n#### Parallel processing / \"races\"\n\nSometimes, for performance reasons, it's convenient to do more than one thing at the same time.  In many languages, this can be tricky.  But in JavaScript (and thus, in Node.js), this kind of optimization is supported right out of the box.\n\nHowever, note that this _is_ one area where you can't just use `await`-- you'll need to use either callbacks or promise chaining.\n\n> **When should I optimize my code with parallel processing?**\n> \n> It's never worth optimizing until you've hit an _actual_ bottleneck, usually as far as per-user latency (or more rarely, as far as overall scalability).  It's never worth inheriting the complexity of parallel processing until you're 100% sure your performance issue is related to \"having to wait for one thing to finish before the next thing can start\".  If you're having performance issues for other reasons (e.g. slow SQL queries, slow 3rd party APIs, or a lack of indexes in your Mongo database), this won't help you at all, and like most forms of premature optimization, it'll just make your app more bug-prone, more complicated to understand, and harder to optimize in the future if _real_ performance issues arise.\n>\n> That said, if you actually need the performance boost from parallel processing, you're in luck:  when Node.js puts its mind to it, the engine can be incredibly fast.\n\nTo manage \"races\" between deferred objects while still performing tasks simultaneously, you can use `async.each()` -- for example, here's the `async.eachSeries()` code from above again, but optimized to run on groups of letters simultaneously, while still processing letters within those groups in sequential order:\n\n```javascript\nvar results = [];\nasync.each(['abc','def','ghi','jkl'], function (group, next) {\n\n  var theseLetters = group.split('');\n  var resultsForThisGroup = [];\n  async.eachSeries(theseLetters, function (letter, next) {\n    doStuff(letter).exec(function (err, resultForThisLetter){\n      if (err) { return next(err); }\n      resultsForThisGroup.push(resultForThisLetter)\n      return next();\n    });\n  },// ~∞%°\n  function (err) {\n    if (err) { return next(err); }\n\n    resultsForThisGroup.forEach(function(letter){\n      results.push(letter);\n    });\n\n    return next();\n  });\n\n},// ~∞%°\nfunction afterwards(err) {\n  if (err) {\n    console.error(err);\n    return res.sendStatus(500);\n  }\n  return res.json(results);\n});\n```\n\n> [More background on asynchronous vs. synchronous flow control in general](https://gist.github.com/mikermcneil/755a2ae7cc62d9a59656ab3ba9076cc1)\n\n\n\n\n## API reference\n\n### Implementor interface\n\n#### parley()\n\nBuild and return a deferred object.\n\nAs its first argument, expects a function (often called the handler, or more specifically \"handleExec\") that will run whenever userland code executes the deferred object (e.g. with `await`, `.exec()`, or `.then()`).\n\n```javascript\nvar deferred = parley(function (done) {\n  // • If something goes wrong, call `done(new Error('something went wrong'))`\n  // • If everything worked out, and you want to send a result back, call `done(undefined, result);`\n  // • Otherwise, if everything worked out but no result is necessary, simply call:\n  return done();\n});\n```\n\nThis first argument is mandatory-- it defines what your implementation _actually does_ when the `await` or `.exec()` is triggered.\n\n##### Optional callback\nThere is also an optional second argument you can use: another function that, if provided, will cause your handler (the first arg) to run _immediately_.\n\nThis provides a simple, optimized shortcut for exposing an optional callback to your users.\n\n> Why bother?  Well, for one thing, it's stylistically a good idea to give users a way to call your handler with as little sugar on top as possible.  More rarely, for very performance-sensitive applications, direct callback usage does provide a mild performance benefit.\n\n```javascript\nvar deferred = parley(function (done){\n  // ...\n}, optionalCbFromUserland);\n\n// Note: if an optional cb was provided from userland, then parley **will not return anything**.\n// In other words:\nif (optionalCbFromUserland) {\n  assert(deferred === undefined);\n}\n```\n\n##### Custom methods\nThe safest way to attach custom methods is by using parley's optional 3rd argument.  The usual approach is for these custom methods to be chainable (i.e. return `this`).\n\n```javascript\nvar privateMetadata = {};\n\nvar deferred = parley(function (done){\n  // ...\n}, optionalCbFromUserland, {\n  someCustomMethod: function(a,b,c){\n    privateMetadata = privateMetadata || {};\n    privateMetadata.foo = privateMetadata.foo || 1;\n    privateMetadata.foo++;\n    return deferred;\n  }\n});\n```\n\n> Don't use this approach to define non-functions or overrides with special meaning (e.g. `inspect`, `toString`, or `toJSON`).\n> To do that, just set the property directly-- for example:\n> ```javascript\n> deferred.inspect = function(){ return '[My cool deferred!]'; };\n> ```\n\n\n#### Stack traces\n\nWhen building asynchronous functions, you're likely to encounter issues with unhelpful stack traces.  There's no _easy_ solution to this problem per se, but over the years, our team has developed a decent approach to solving this problem.  It involves using temporary Error instances known colloquially as \"omens\":\n\n```javascript\nconst flaverr = require('flaverr');\n\n// Take a snapshot of the stack trace BEFORE doing anything asynchronous.\nvar omen = flaverr.omen();\n\nvar deferred = parley((done)=>{\n  \n  // Wait for up to 8 seconds.\n  var msToWait = 8 * Math.floor(Math.random()*1000);\n  setTimeout(()=>{\n    if (Math.random() > 0.5) {\n      // Use our \"omen\" (stack trace snapshot) to \"flavor\" our actual error.\n      return done(flaverr({\n        code: 'E_LUCK_RAN_OUT',\n        message: 'Too bad, your luck ran out!'\n      }, omen));\n    }\n    else {\n      return done();\n    }\n  }, msToWait);\n \n}, optionalCbFromUserland, {\n  someCustomMethod: (a,b,c)=>{\n    privateMetadata = privateMetadata || {};\n    privateMetadata.foo = privateMetadata.foo || 1;\n    privateMetadata.foo++;\n    return deferred;\n  }\n}, undefined, omen);\n```\n\nNow, when your function gets called, if there's an error, the developer who wrote the relevant code will get an excellent stack trace.\n\n\n#### Timeouts\n\nSometimes, it's helpful to automatically time out if execution takes too long.  In parley, Sails, Waterline, and the node-machine project, this is supported right out of the box.\n\nFor instance, in the code from the previous example above, the execution of our little function might take anywhere from one or two milliseconds all the way up to 8 entire seconds.  But what if we wanted it to time out after only 2 seconds?  For that, we can use the fourth argument to parley: the timeout.\n\nThis should be a number, expressed in milliseconds:\n\n```javascript\n// … same code as the example above …\n\n// This time, with a timeout of 2 seconds (2000 milliseconds):\nvar deferred = parley((done)=>{\n  // … same code as the example above …\n}, optionalCbFromUserland, {\n  … custom methods here …\n}, 2000);\n```\n\nIf the timeout is exceeded, an error is triggered, and any subsequent calls to `done` from your provided custom implementation are ignored.\n\n#### Improving stack traces of built-in errors\n\nFor important modules that impact many developers (or for authors that really care about the sanity of their users, and who want to make it easier to debug their code), it is sometimes useful to go so far as improving the stack trace of _even parley's built-in errors_ such as timeouts.  For this, simply use the 5th argument: the \"omen\".\n\nTo stick with our running example:\n\n```javascript\n// … same code as the example above …\n\n// Take a snapshot of the stack trace BEFORE doing anything asynchronous.\nvar omen = new Error('omen');\n\nvar deferred = parley((done)=>{\n  // … same code as the example above …\n}, optionalCbFromUserland, {\n  … custom methods here …\n}, 2000, omen);\n```\n\n\n\n\n### Userland interface\n\nThe deferred object returned by `parley()` exposes a few different methods.\n\n#### .exec()\n\n```javascript\nparley(function(done){ return done(undefined, 1+1); })\n.exec(function (err, result) {\n  // => undefined, 2\n});\n```\n\n```javascript\nparley(function(done){ return done(new Error('whoops'), 1+1); })\n.exec(function (err, result) {\n  // => [Error: whoops], undefined\n});\n```\n\n#### .then()\n\n```javascript\nparley(function(done){ return done(undefined, 1+1); })\n.then(function (result) {\n  // => 2\n});\n```\n\n#### .catch()\n\n```javascript\nparley(function(done){ return done(new Error('whoops'), 1+1); })\n.catch(function (err) {\n  // => [Error: whoops]\n});\n```\n\n#### .toPromise()\n\n```javascript\nvar promise1 = parley(function(done){ return done(undefined, 1+1); }).toPromise();\nvar promise2 = parley(function(done){ setTimeout(function(){ return done(); }, 10); }).toPromise();\n\nPromise.all([\n  promise1,\n  promise2\n])\n.then(function(result){\n  // => [2, undefined]\n}).catch(function (err) {\n\n});\n```\n\n\n#### Other methods\n\nImplementors may also choose to attach other methods to the deferred object (e.g. `.where()`).  See \"Custom methods\" above for more information.\n\n\n## Contributing &nbsp; [![Master Branch Build Status](https://travis-ci.org/mikermcneil/parley.svg?branch=master)](https://travis-ci.org/mikermcneil/parley) &nbsp; [![Master Branch Build Status (Windows)](https://ci.appveyor.com/api/projects/status/tdu70ax32iymvyq3?svg=true)](https://ci.appveyor.com/project/mikermcneil/parley)\n\nPlease observe the guidelines and conventions laid out in the [Sails project contribution guide](http://sailsjs.com/documentation/contributing) when opening issues or submitting pull requests.\n\n[![NPM](https://nodei.co/npm/parley.png?downloads=true)](http://npmjs.com/package/parley)\n\n## Pronunciation\n\n[`/ˈpärlē/`](http://www.macmillandictionary.com/us/pronunciation/american/parley)\n\n> _Rather than picking barley and getting snarly, she decided to `npm install parley` and listen to some Bob Marley._\n\n## License\n\nThis package, like the [Sails framework](http://sailsjs.com), is free and open-source under the [MIT License](http://sailsjs.com/license).\n\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/mikermcneil/parley.git"
  },
  "scripts": {
    "bench": "node ./node_modules/mocha/bin/mocha test/*.benchmark.js",
    "custom-tests": "node ./node_modules/mocha/bin/mocha test/*.test.js",
    "lint": "node ./node_modules/eslint/bin/eslint . --max-warnings=0 --ignore-pattern 'test/' && echo '✔  Your code looks good.'",
    "test": "npm run lint && npm run custom-tests && npm run bench"
  },
  "version": "3.3.4"
}
